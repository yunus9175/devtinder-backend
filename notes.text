# DevTinder Backend – Project Notes

## Project overview
- Backend API for DevTinder (developers meet & discuss).
- REST API with Express, MongoDB (Mongoose), JWT auth, bcrypt, validation.

## Tech stack
- Node.js, Express 5
- MongoDB + Mongoose
- bcrypt (password hashing)
- jsonwebtoken (JWT sign/verify)
- cookie-parser (read cookies)
- validator (email, strong password)

## Project structure
src/
  app.js              # Entry point, all routes
  config/database.js
  middlewares/auth.js # userAuth (JWT from cookie → req.user); used on protected routes
  models/user.js      # User schema + instance methods getJWT(), getValidPassword()
  models/todo.js
  utils/validation.js # validateSignupData, validateTodoData

## Implemented API routes

Base URL: http://localhost:8080

### Auth (public)
- POST /signup       – Create user (validateSignupData, bcrypt hash, save user, return user without password)
- POST /login        – Login (email+password, user.getValidPassword(), user.getJWT(), set token in cookie with 8h expiry, return user)

### Auth & user (protected: userAuth middleware)
- GET  /profile             – Current user (req.user set by userAuth)
- POST /sendConnectionRequest – Send connection request (uses req.user.firstName, lastName)
- GET  /userbyemail         – Get user by email (body: { email })
- GET  /feed                – Get all users
- DELETE /user/:id          – Delete user by id
- PATCH /user/:id           – Update user (allowed: firstName, lastName, email, password, age, gender, profilePicture, about, skills; skills max 10)

### Todo
- POST   /todo          – Create todo (validateTodoData, check duplicate title, save)
- GET    /todo          – Get all todos
- GET    /todo/status   – Get todos by completed (?completed=true|false)
- PATCH  /todo/:id     – Update todo by id
- DELETE /todo/:id     – Delete todo by id

## Route regex reference (Express)
- "/ab?c"   → "/abc" or "/ac"
- "/ab+"    → "/ab", "/abb", "/abbb"
- "/ab*b"   → "/ab", "/abb", "/abbb", "/abbbbb"
- "/ab{3}b" → "/abbbb"
- "/ab{3,5}b" → "/abbbb" or "/abbbbb"
- "/a(bc)+d" → "/abcbcd", "/abcbcbcd"
- Example: /user/[a-z0-9]+ matches /user followed by one or more lowercase letters or digits

## req.query vs req.params
- req.query  – query string (?key=value)
- req.params – route params (/user/:id → req.params.id)

## Middleware and next()
- Route order: Express matches TOP TO BOTTOM. Put specific routes before generic ones.
- next() passes control to the next middleware; don’t call next() after sending a response.
- Example: app.use("/admin", adminAuth) runs adminAuth for all /admin/* routes before the route handler.

## API-level validation (our pattern)
- Allowed fields for PATCH /user/:id:
  const ALLOWED_UPDATES = ["firstName","lastName","email","password","age","gender","profilePicture","about","skills"];
  const isValidUpdate = Object.keys(updateData).every(key => ALLOWED_UPDATES.includes(key));
  if (!isValidUpdate) return res.status(400).json({ message: "Invalid update data" });

## Password security (bcrypt)
- Signup: hash password with bcrypt.hash(password, 10), store hashed value only.
- Login: compare with bcrypt.compare(plainPassword, user.password).
- Never store or send plain passwords.

## JWT (our flow)
- Login: user.getJWT() (User instance method, 10d expiry) → res.cookie("token", token, { expires: 8h }).
- Protected routes: userAuth middleware reads req.cookies.token, jwt.verify(), loads user, sets req.user, next().
- Use env var for JWT secret in production.

## User model instance methods (src/models/user.js)
- getJWT() – returns JWT signed with { _id }, expiresIn 10d (used at login).
- getValidPassword(plainPassword) – returns true if plainPassword matches stored hash (used at login).

## Auth middleware (src/middlewares/auth.js)
- userAuth: read token from req.cookies, verify JWT, find user by _id, set req.user, next(). On missing/invalid token or user not found, respond 401 and do not call next().

## Duplicate key (MongoDB)
- unique: true in schema creates a unique index; duplicate insert fails with code 11000.
- In signup catch: if (error.code === 11000 && error.keyPattern?.email) return res.status(409).json({ message: "Email already exists" });

## Indexes (optimize backend / DB queries)
- Indexes speed up find, findOne, sort, and filter; without them MongoDB may scan the whole collection (slow as data grows).
- Add indexes on fields you query often: login by email, get by _id, feed filters (e.g. age, gender), sort (e.g. createdAt).

### In Mongoose
- Single field: in schema set unique: true (e.g. email) or add index: true.
- Compound index (multiple fields): schema.index({ field1: 1, field2: -1 }) for queries that filter/sort by both.
- Example (user): email already has unique: true. For feed by age + gender: userSchema.index({ age: 1, gender: 1 }).
- Example (todo): find by completed: todoSchema.index({ completed: 1 }); for sort by createdAt: index({ createdAt: -1 }).

### Compound indexes
- Compound index = index on two or more fields together. Use when you filter or sort by multiple fields in the same query.
- Field order matters: MongoDB can use the index only for queries that match a left-to-right prefix of the index keys.
  - Index { a: 1, b: 1, c: 1 } is used for find({ a }), find({ a, b }), find({ a, b, c }); not for find({ b }) or find({ c }) alone.
- Put the most selective or most often filtered field first; add sort field next if you sort by it (e.g. createdAt).
- In Mongoose: after schema definition, before model(), add e.g. userSchema.index({ age: 1, gender: 1 }); or todoSchema.index({ completed: 1, createdAt: -1 }).
- 1 = ascending, -1 = descending (for sort order in the index).

### When to add
- Any field used in find(), findOne(), or as filter in find({ ... }).
- Fields used in sort() (e.g. createdAt, updatedAt).
- Unique constraints (email, username) → unique index.

### Trade-offs
- Reads get faster; writes slightly slower (index must be updated); indexes use extra storage.
- Don’t over-index: only fields that appear in queries or need uniqueness.

### Check existing indexes (Mongo shell or Compass)
- db.users.getIndexes()
- db.todos.getIndexes()
- Ensure unique index on email exists so duplicate signups are rejected and lookups are fast.

